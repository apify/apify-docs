---
title: Pay per event (PPE)
description: Learn how to monetize your Actor with pay-per-event (PPE) pricing, charging users for specific actions like Actor starts, dataset items, or API calls, and understand how to set profitable, transparent event-based pricing.
slug: /actors/publishing/monetize/pay-per-event
sidebar_position: 3
---

**Learn how to monetize your Actor with pay-per-event (PPE) pricing, charging users for specific actions like Actor starts, dataset items, or API calls, and understand how to set profitable, transparent event-based pricing.**

---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The pay-per-event pricing model offers a flexible monetization option for Actors on Apify Store. Unlike pay per result, PPE allows you to charge users based on specific events triggered programmatically by your Actor's code.

PPE lets you define pricing for individual events. You can charge for specific events directly from your Actor by calling the [PPE charging API](/api/v2/post-charge-run), or through [JS](/sdk/js/reference/class/Actor#charge)/[Python](/sdk/python/reference/class/Actor#charge) SDK Common events include Actor start, dataset item creation, and external API calls.

The details on how your cost is computed can be found in [Example of a pay-per-event pricing model](#example-of-a-pay-per-event-pricing-model).

## How is profit computed

Your profit is calculated from the mentioned formula:

`profit = (0.8 * revenue) - platform costs`

where:

- _Revenue_: The amount charged for events via the PPE charging API or through JS/Python SDK. You receive 80% of this revenue.
- _Platform costs_: The underlying platform usage costs for running the Actor, calculated in the same way as for PPR. For more details, visit the [Computing your costs for PPE and PPR Actors](#computing-your-costs-for-ppe-and-ppr-actors) section.

Only revenue and cost for Apify customers on paid plans are taken into consideration when computing your profit. Users on free plans are not reflected there.

:::note Negative profit isolation

An Actor's negative net profit does not affect the positive profit of another Actor. For aggregation purposes, any Actor with a negative net profit is considered to have a profit of $0.

- _Previously:_ `Total Profit = (-$90) + $100 = $10`
- _Now:_ `Total Profit = $0 + $100 = $100`

:::

## How to set pricing for pay-per-event Actors

1. _Understand your costs_: Analyze resource usage (e.g CPU, memory, proxies, external APIs) and identify cost drivers
1. _Define clear events_: break your Actor's functionality into measurable, chargeable events.
1. _Common use cases_:
   1. _For scraping_: combine Actor start and dataset items pricing to reflect setup and per-result cost.
   1. _Beyond scraping_: Account for integrations with external systems or external API calls.
1. _External API costs_: Account for additional processing costs.
1. _Test your pricing_: Run your Actor and analyze cost-effectiveness using a special dataset.
1. _Communicate value_: Ensure pricing reflects the value provided and is competitive.

## Best practices for pay-per-event Actors

Use our SDKs (JS and, Python or use [`apify actor charge`](/cli/docs/next/reference#apify-actor-charge-eventname) when using our Apify CLI) to simplify PPE implementation into your Actor. This tool can handle pricing, usage tracking, idempotency keys, API errors, and, event charging via an API.

You can also choose not to use it, but then you must handle API integration and possible edge cases manually.

### Set memory limits

Set memory limits using `minMemoryMbytes` and `maxMemoryMbytes` in your [`actor.json`](https://docs.apify.com/platform/actors/development/actor-definition/actor-json) file to control platform usage costs.

```json
{
    "actorSpecification": 1, 
    "name": "name-of-my-scraper",
    "version": "0.0",
    "minMemoryMbytes": 512,
    "maxMemoryMbytes": 1024,
}
```

:::note Memory requirements for browser-based scraping

When using browser automation tools like Puppeteer or Playwright for web scraping, increase the memory limits to accommodate the browser's memory usage.

:::

### Charge for "Actor start"

Charge for "Actor start" to prevent users from running your Actor for free.

<Tabs groupId="main">
<TabItem value="JavaScript" label="JavaScript">

```js
import { Actor } from 'apify';

const chargeForActorStart = async () => {
  const chargingManager = Actor.getChargingManager();

  // Don't charge the "Actor start" event again after Actor migration
  if (chargingManager.getChargedEventCount("actor-start") === 0) {
    await Actor.charge({
      "eventName": "actor-start",
    });
  }
}

await Actor.init();

const main = async () => {
  await chargeForActorStart();

  // Rest of the Actor logic
};

await main();

await Actor.exit();
```

</TabItem>
<TabItem value="Python" label="Python">

```python
from apify import Actor

async def charge_for_actor_start():
    charging_manager = Actor.get_charging_manager()

    # Don't charge the "Actor start" event again after Actor migration
    if charging_manager.get_charged_event_count("actor-start") == 0:
        await Actor.charge(event_name="actor-start")

async def main():
    await Actor.init()
    
    await charge_for_actor_start()

    # Rest of the Actor logic

    await Actor.exit()
```

</TabItem>
</Tabs>

:::note Actor migrations and charging

Actors can migrate between servers during execution, which restarts the process and clears memory. When using PPE charging, avoid charging the start event multiple times after a migration by checking your charging state.

:::

### Charge for invalid input

Charge for things like URLs that appear valid but lead to errors (like 404s) since you actually had to open the page to discover the error. Return error items with proper error codes and messages instead of failing the entire Actor run.

<Tabs groupId="main">
<TabItem value="JavaScript" label="JavaScript">

```js
import { Actor } from 'apify';

const processUrl = async (url) => {
  const response = await fetch(url);
    
  if (response.status === 404) {
    // Charge for the work done (opening the page)
    await Actor.charge({
        eventName: "scraped-result",
    });
      
    // Return error item instead of failing
    await Actor.pushData({
      url: url,
      error: "404",
      errorMessage: "Page not found"
    });
    
    return;
  }

  // Rest of the Actor logic
};

await Actor.init();

const main = async () => {
  const input = await Actor.getInput();
  const { urls } = input;
  
  for (const url of urls) {
    await processUrl(url);
  }

  // Rest of the Actor logic
};

await main();

await Actor.exit();
```

</TabItem>
<TabItem value="Python" label="Python">

```python
from apify import Actor
import requests

async def process_url(url):
    response = requests.get(url)
    
    if response.status_code == 404:
        # Charge for the work done (opening the page)
        await Actor.charge(event_name='scraped-result')
        
        # Return error item instead of failing
        await Actor.push_data({
            'url': url,
            'error': '404',
            'errorMessage': 'Page not found'
        })
        
        return

    # Rest of the Actor logic

async def main():
    await Actor.init()
    
    input_data = await Actor.get_input()
    urls = input_data.get('urls', [])
    
    for url in urls:
        await process_url(url)
    
    # Rest of the Actor logic
    
    await Actor.exit()
```

</TabItem>
</Tabs>

### Respect user spending limits

Finish the Actor run once charging reaches user-configured Maximum cost per run. Apify SDKs (JS and Python) return ChargeResult that helps determine when to finish.

The `eventChargeLimitReached` property checks if the current event type can be charged more. If you have multiple event types, analyze the `chargeableWithinLimit` property to see if other events can still be charged before stopping the Actor.

<Tabs groupId="main">
<TabItem value="JavaScript" label="JavaScript">

```js
import { Actor } from 'apify';

const chargForApiProductDetail = async () => {
  const chargeResult = await Actor.charge({
    eventName: "product-detail",
  });

  return chargeResult;
};

await Actor.init();

const main = async () => {
  // API call, or any other logic that you want to charge for

  const chargeResult = await chargForApiProductDetail();

  if (chargeResult.eventChargeLimitReached) {
    await Actor.exit();
  }

  // Rest of the Actor logic
};

await main();

await Actor.exit();
```

</TabItem>
<TabItem value="Python" label="Python">

```python
from apify import Actor

async def charge_for_api_product_detail():
    charge_result = await Actor.charge(event_name='product-detail')

    return charge_result

async def main():
    await Actor.init()
    
    # API call, or any other logic that you want to charge for

    charge_result = await charge_for_api_product_detail()

    if charge_result.event_charge_limit_reached:
        await Actor.exit()

    # Rest of the Actor logic

    await Actor.exit()
```

</TabItem>
</Tabs>

:::note Crawlee integration and spending limits

When using [Crawlee](https://crawlee.dev/), use `crawler.autoscaledPool.abort()` instead of `Actor.exit()` to gracefully finish the crawler and allow the rest of your code to process normally.

:::

### Keep pricing simple with fewer events

Try to limit the number of events. Fewer events make it easier for users to understand your pricing and predict their costs.

### Make events produce visible results

Try to make your event have tangible artifacts that users can see and understand (this might not be possible when using external APIs). Each charged event should produce something concrete in the user's dataset.

Good examples:

- _"scraped-product" event_: Each charge adds one product record to the dataset
- _"processed-image" event_: Each charge adds one processed image to the dataset  
- _"extracted-review" event_: Each charge adds one review to the dataset

Avoid charging for:

- Internal processing steps that don't produce visible results
- API calls that don't generate user-visible data
- Setup or configuration steps

This helps users understand exactly what they're paying for and builds trust in your pricing model.

### Use idempotency keys to prevent double charges

If you're not using the Apify SDKs (JS/Python), you need to handle idempotency (ensuring the same operation produces the same result when called multiple times) manually to prevent charging the same event multiple times.

## Example of a pay-per-event pricing model

You make your Actor pay-per-event and set the following pricing:

- _"actor-start" event_: $0.10 per start
- _"scraped-product" event_: $0.01 per product
- _"scraped-product-detail" event_: $0.05 per detail

During the first month, three users use your Actor:

- _User 1 (paid plan)_: Starts Actor 5 times, scrapes 1,000 products, makes 50 product details
  - Charges: 5 × $0.10 + 1,000 × $0.01 + 50 × $0.05 = $0.50 + $10.00 + $2.50 = $13.00
- _User 2 (paid plan)_: Starts Actor 2 times, scrapes 500 products, makes 20 product details  
  - Charges: 2 × $0.10 + 500 × $0.01 + 20 × $0.05 = $0.20 + $5.00 + $1.00 = $6.20
- _User 3 (free plan)_: Starts Actor 1 time, scrapes 100 products, makes 5 product details
  - Charges: 1 × $0.10 + 100 × $0.01 + 5 × $0.05 = $0.10 + $1.00 + $0.25 = $1.35

Let's say the underlying platform usage for the first user is $2.50, for the second $1.20, and for the third $0.30.

Your profit is computed only from the first two users, since they are on Apify paid plans. The revenue breakdown is:

- _Total revenue_: $13.00 + $6.20 = $19.20
- _Total underlying cost_: $2.50 + $1.20 = $3.70
- _Your profit_: 80% of revenue minus costs = 0.8 × $19.20 - $3.70 = $11.66

## PPE event names

To implement pay-per-event pricing, you need to define specific events in your Actor code. You can retrieve the list of available pricing event names using the [Get Actor](https://apify.com/docs/api/v2/act-get) API endpoint.

## Next steps

- Check out the [Pricing and costs](./pricing_and_costs.mdx) section to learn how to compute your costs.
